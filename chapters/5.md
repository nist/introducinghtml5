# Canvas

If the video element is the poster boy of HTML5, the canvas element is definitely the Han Solo of HTML5. It's one of the larger parts of the HTML5 specification, and in fact the canvas API, the 2D drawing context, has been split into a separate document, though the canvas element itself is still part of the official HTML5 spec.

The canvas element provides an API for two-dimensional drawing--lines, fills, images, text, and so on. The API has already been used in a huge range of situations, including (interactive) backgrounds to websites, navigation elements, graphing tools, full-fledged applications, games, and emulators. Who knew Super Mario canvas-based games would open the eyes of so many developers!

If you think back to the days of the version of MS Paint that came with Windows 95, you can imagine some of the functionality of canvas. In fact, Paint has been replicated using the canvas element, as shown in Figure 5.1. Applications that aim to become full-fledged vector drawing suites (Figure 5.2) are popping up all over the Web (whereas Scalable Vector Graphics [SVG] would be a better choice--see the "When to use Canvas, when to use SVG" sidebar later in this chapter). As these applications are based on Open Web technology, they work in a browser on more devices, too. The Harmony application shown in Figure 5.3 even works on mobile devices, including the iPhone and Android phones.

The 2D API is large enough that I suspect we'll see entire books dedicated to the subject. Since I have only one chapter to talk about it, I'll primarily show you the basics. But I'll also include some of the funky stuff you can do with the canvas element, like capturing frames from a video or processing individual pixels from an image inside the canvas. I'll even show you how to export to files ready to be saved to your desktop. And I'll show you how to create your first animation, which might even hark back to the days of BASIC computing.

{{figure 5.1

  Figure 5.1 MS Paint replicated using the canvas element.

}}

{{figure 5.2

  Figure 5.2 More advanced drawing applications are emerging using canvas.

}}

{{figure 5.3

  Figure 5.3 The canvas drawing demo Harmony also works, unmodified, on mobile browsers.

}}

## Canvas basics

The hello world of any canvas demo starts with putting the canvas element on your page. Initially the canvas is completely invisible and by default it is 300 pixels wide by 150 pixels high:

```html
<!DOCTYPE html>
<title>canvas hello world</title>
<canvas></canvas>
```

The canvas element is now in place. Use JavaScript to get the 2D context to allow you to draw:

```js
var ctx = document.querySelector('canvas').getContext('2d');
```

Now that you have the context, you have access to the full API to draw as you please. For instance, you can add simple shapes to your canvas (Figure 5.4):

```js
ctx.fillRect(10, 20, 50, 50);
```

{{aside

# What about browser support?

Browser support is fairly good for the canvas element; four of the big five browsers support canvas in the latest versions of the browser (and in fact its support is fairly good in previous versions of the browsers, too). "What about Internet Explorer?" is the question that is perpetually asked.

For versions of IE that don't support canvas (IE8 and below), you can shim canvas support in a few ways. The first is FlashCanvas which looks to be the most promising. It does have to rely on Flash as the backup, but it should read all the canvas code and translate it for you to a Flash graphics layer: [http://flashcanvas.net](http://flashcanvas.net).

Similarly, there is a method using Silverlight and a library called html5canvas ([http://blogs.msdn.com/delay/archive/2009/08/24/using-one-platform-to-build-another-html-5-s-canvas-tag-implemented-usingsilverlight.aspx](http://blogs.msdn.com/delay/archive/2009/08/24/using-one-platform-to-build-another-html-5-s-canvas-tag-implemented-usingsilverlight.aspx)); and finally there is a library called excanvas ([http://code.google.com/p/explorercanvas/](http://code.google.com/p/explorercanvas/)), which translates the canvas API to Microsoft's VML.

These libraries don't cover the entirety of the 2D API, but they do cover most of the commonly used methods. Several demos show comparisons from examples in the wild. Out of these options, the web community appears pretty positive about the FlashCanvas polyfill. It's just a little ironic to me that we're relying on Flash (again) for a technology that's touted as replacing Flash. But, hey, this is the way of the web.

It's worth pointing out and being wary that these polyfills won't have the same performance as native canvas. Without seeing charts upon charts upon charts, I would expect the FlashCanvas to perform the best of the lot, but it won't be a like for like performance, particularly compared to when the browser has hardware-accellerated canvas rendering as IE9 does.

}}

The arguments to fillRect are x, y, width, and height. The x and y coordinates start in the top left. As shown in Figure 5.4, the default colour is black. Let's add some colour and draw an outline around the canvas so that the canvas looks like Figure 5.5:

```
ctx.fillStyle = 'rgb(0, 255, 0)';
ctx.fillRect(10, 20, 50, 50); // creates a solid square
ctx.strokeStyle = 'rgb(0, 182, 0)';
ctx.lineWidth = 5;
ctx.strokeRect(9, 19, 52, 52); // draws an outline
```

In the previous code listing, you're drawing twice on the canvas: once with fillRect and once with strokeRect. When you're not drawing, you're setting the colour and style of the 2D context which must happen before the fill or stroke happens, otherwise the default colour of black is used. Along with CSS colours (for example, RGB, hex, RGBA, and so on), fillStyle and strokeStyle also accept gradients and patterns generated using the 2D API.